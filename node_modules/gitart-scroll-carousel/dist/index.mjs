import { unref, defineComponent, ref, computed, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, watch, reactive, onMounted, nextTick, onBeforeUnmount, resolveComponent, createBlock, resolveDynamicComponent, mergeProps, withCtx, Fragment, renderList, renderSlot, createVNode } from "vue";
import { _ as _export_sfc } from "./GSArrow.js";
export { G as GSLayoutDefault } from "./GSLayoutDefault.js";
export { G as GSLayoutNumeric } from "./GSLayoutNumeric.js";
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let preventLeading = !leading;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = unref(ms);
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration) {
      lastExec = Date.now();
      if (preventLeading)
        preventLeading = false;
      else
        invoke();
    }
    if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        if (!leading)
          preventLeading = true;
        clear();
        invoke();
      }, duration);
    }
    if (!leading && !timer)
      timer = setTimeout(() => preventLeading = true, duration);
  };
  return filter;
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}
function useThrottleFn(fn, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function LinearEasing(x) {
  return x;
}
var src = function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function BezierEasing(x) {
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
};
const easingTypes = {
  ease: [0.25, 0.1, 0.25, 1],
  linear: [0, 0, 1, 1],
  easeIn: [0.42, 0, 1, 1],
  easeOut: [0, 0, 0.58, 1],
  easeInOut: [0.42, 0, 0.58, 1],
  default: [0.5, 0, 0.5, 1]
};
const defaults = {
  FPS: 60,
  BEZIER: easingTypes.default
};
const animate = ({
  from,
  to,
  duration,
  bezier: bezier2 = defaults.BEZIER,
  on,
  completed,
  stopped,
  done
}) => {
  const easingFn = src(...bezier2);
  const difference = to - from;
  const timestamp = Date.now();
  let rqfId = 0;
  let currentValue = from;
  const fn = () => {
    let progress = (Date.now() - timestamp) / duration;
    if (progress > 1)
      progress = 1;
    currentValue = from + difference * easingFn(progress);
    on(currentValue);
    if (progress === 1) {
      completed == null ? void 0 : completed(currentValue);
      done == null ? void 0 : done(currentValue);
      return;
    }
    rqfId = requestAnimationFrame(fn);
  };
  rqfId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(rqfId);
    stopped == null ? void 0 : stopped(currentValue);
    done == null ? void 0 : done(currentValue);
  };
};
const useAnimateNumber = (onChangeValue) => {
  let value = 0;
  let stopFn = null;
  const setSmoothly = (to, from) => {
    stopFn == null ? void 0 : stopFn();
    if (from)
      value = from;
    stopFn = animate({
      duration: 400,
      from: value,
      to,
      on: (current) => {
        value = current;
        onChangeValue(current);
      }
    });
  };
  const setImmediately = (to) => {
    value = to;
    onChangeValue(to);
  };
  return {
    setSmoothly,
    setImmediately
  };
};
var GSIndicator_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1 = defineComponent({
  name: "GSIndicator",
  props: {
    barWidthPercent: {
      type: Number,
      required: true
    },
    barOffsetPercent: {
      type: Number,
      required: true
    }
  },
  emits: {
    "smooth-scroll": (_) => true,
    "scroll": (_) => true,
    "scroll:start": () => true,
    "scroll:end": () => true
  },
  setup(props, { emit }) {
    const indicatorRef = ref();
    const startBarX = ref(0);
    const startBarOffsetPercent = ref(0);
    const isScrolling = ref(false);
    const mouseMoveHandler = (event) => {
      const barX = event.clientX;
      const difference = barX - startBarX.value;
      const width = indicatorRef.value.offsetWidth;
      const differencePercent = difference / width * 100;
      const minOffset = 0;
      const maxOffset = 100 - props.barWidthPercent;
      let barOffsetPercent = startBarOffsetPercent.value + differencePercent;
      if (barOffsetPercent < minOffset)
        barOffsetPercent = minOffset;
      else if (barOffsetPercent > maxOffset)
        barOffsetPercent = maxOffset;
      emit("scroll", {
        barOffsetPercent
      });
    };
    const mouseUpHandler = () => {
      document.removeEventListener("mouseup", mouseUpHandler);
      document.removeEventListener("mousemove", mouseMoveHandler);
      isScrolling.value = false;
      emit("scroll:end");
    };
    const onMouseDown = (event) => {
      isScrolling.value = true;
      emit("scroll:start");
      document.addEventListener("mouseup", mouseUpHandler);
      document.addEventListener("mousemove", mouseMoveHandler);
      startBarX.value = event.clientX;
      startBarOffsetPercent.value = props.barOffsetPercent;
    };
    const onTrackClick = (event) => {
      const x = event.clientX;
      const indicatorEl = indicatorRef.value;
      const indicatorX = indicatorEl.getBoundingClientRect().left;
      const relativeX = x - indicatorX;
      const relativePosition = relativeX / indicatorEl.offsetWidth;
      const barOffsetPercent = (relativePosition - props.barWidthPercent / 100 / 2) * 100;
      emit("smooth-scroll", {
        barOffsetPercent
      });
    };
    const barStyle = computed(() => {
      return {
        width: `${props.barWidthPercent}%`,
        left: `${props.barOffsetPercent}%`
      };
    });
    return {
      indicatorRef,
      barStyle,
      startBarX,
      startBarOffsetPercent,
      moving: isScrolling,
      onTrackClick,
      onMouseDown
    };
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "indicatorRef",
    class: normalizeClass(["gsc-indicator", {
      "gsc-indicator--scrolling": _ctx.moving
    }])
  }, [
    createElementVNode("div", {
      class: "gsc-indicator__track",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onTrackClick && _ctx.onTrackClick(...args))
    }),
    createElementVNode("div", {
      class: "gsc-indicator__bar",
      style: normalizeStyle(_ctx.barStyle),
      onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseDown && _ctx.onMouseDown(...args))
    }, null, 36)
  ], 2);
}
var GSIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-1dcebdc5"]]);
var GSCarousel_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "GSCarousel",
  components: {
    GSIndicator
  },
  props: {
    currentItem: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      required: true
    },
    itemsToShow: {
      type: Number,
      required: true
    },
    keyField: {
      type: String,
      default: null
    },
    itemGap: {
      type: [String, Number],
      default: "0",
      validator: (value) => {
        const gaps = value.toString().split(" ");
        return gaps.length <= 2 && gaps.every((gap) => !isNaN(parseInt(gap)));
      }
    },
    previewSize: {
      type: Number,
      default: 120
    },
    sticky: {
      type: Boolean,
      default: false
    },
    layout: {
      type: Object,
      required: true
    },
    layoutProps: {
      type: Object,
      required: false,
      default: null
    },
    ssrItemMinWidth: {
      type: [Number, String],
      default: null
    },
    ssrItemMaxWidth: {
      type: [Number, String],
      default: null
    }
  },
  emits: {
    "update:current-item": (value) => true
  },
  setup(props, { emit, expose }) {
    const initialized = ref(false);
    const trackRef = ref();
    const disabledSide = ref("left");
    const width = ref(0);
    const scopedCurrentItem = ref(props.currentItem || 0);
    watch(() => props.currentItem, (val) => {
      scopedCurrentItem.value = val;
    });
    const indicatorOptions = reactive({
      isScrolling: false,
      barOffsetPercent: 0,
      barWidthPercent: 0
    });
    const currentItemByPercent = computed(() => {
      const scrollPercent = indicatorOptions.barOffsetPercent / (100 - indicatorOptions.barWidthPercent);
      const item = Math.floor(scrollPercent * (props.items.length - 1));
      return item;
    });
    const {
      setImmediately,
      setSmoothly
    } = useAnimateNumber((offset) => {
      var _a;
      return (_a = trackRef.value) == null ? void 0 : _a.scrollTo({
        left: offset
      });
    });
    const itemGap = computed(() => {
      const gapsArr = props.itemGap.toString().split(" ").map((g) => parseInt(g));
      const y = gapsArr[0];
      const x = gapsArr.length === 1 ? y : gapsArr[1];
      return { y, x };
    });
    const itemWidth = computed(() => {
      return width.value ? (width.value - props.previewSize) / props.itemsToShow : 0;
    });
    const setScrollLeft = (newScrollLeft, smooth = true) => {
      if (smooth) {
        const currentScrollLeft = trackRef.value.scrollLeft;
        setSmoothly(newScrollLeft, currentScrollLeft);
      } else {
        setImmediately(newScrollLeft);
      }
    };
    const getCurrentItem = () => {
      const scrollLeft = trackRef.value.scrollLeft;
      const rawDecimal = scrollLeft / itemWidth.value;
      const absence = 1 - (rawDecimal - Math.floor(rawDecimal));
      let item;
      if (absence < 0.09)
        item = Math.floor(rawDecimal) + 1;
      else
        item = Math.floor(rawDecimal);
      if (item * itemWidth.value < scrollLeft)
        item += 1;
      if (item > props.items.length - 1)
        item = props.items.length - 1;
      return item;
    };
    const onMove = (move) => {
      const scrollLeft = trackRef.value.scrollLeft;
      const item = getCurrentItem();
      if (move === 1) {
        let itemToScroll = item + props.itemsToShow;
        const isLastInvisible = item * itemWidth.value - props.previewSize - 2 > scrollLeft;
        if (isLastInvisible)
          itemToScroll -= 1;
        const maxItem = props.items.length - props.itemsToShow;
        if (itemToScroll > maxItem)
          itemToScroll = maxItem;
        const newScrollLeft = itemWidth.value * itemToScroll;
        setScrollLeft(newScrollLeft);
      } else if (move === -1) {
        if (item === 0)
          return;
        let itemToScroll = item - props.itemsToShow;
        if (itemToScroll < 0)
          itemToScroll = 0;
        const newScrollLeft = itemWidth.value * itemToScroll - props.previewSize;
        setScrollLeft(newScrollLeft);
      }
    };
    const onMoveTo = (index) => {
      if (!itemWidth.value) {
        setTimeout(() => {
          onMoveTo(index);
        }, 50);
        return;
      }
      if (index > getCurrentItem()) {
        const newScrollLeft2 = itemWidth.value * index;
        setScrollLeft(newScrollLeft2);
        return;
      }
      const newScrollLeft = itemWidth.value * index - props.previewSize;
      setScrollLeft(newScrollLeft);
    };
    const onFinishScrollingThrottled = useThrottleFn(() => {
      const item = getCurrentItem();
      if (item !== scopedCurrentItem.value) {
        scopedCurrentItem.value = item;
        emit("update:current-item", scopedCurrentItem.value);
      }
    }, 200);
    let prevScrollLeft = 0;
    const onFinishScrollingDebounced = useDebounceFn((scrollLeft) => {
      setImmediately(scrollLeft);
      if (!props.sticky || indicatorOptions.isScrolling)
        return;
      if (prevScrollLeft < scrollLeft) {
        const newScrollLeft = itemWidth.value * scopedCurrentItem.value;
        setScrollLeft(newScrollLeft);
      } else if (Math.abs(itemWidth.value * scopedCurrentItem.value - scrollLeft) > props.previewSize + 2) {
        const newScrollLeft = itemWidth.value * (scopedCurrentItem.value - 1) - props.previewSize;
        setScrollLeft(newScrollLeft);
      }
      prevScrollLeft = scrollLeft;
    }, 300);
    const onTrackScroll = () => {
      const scrollLeft = trackRef.value.scrollLeft;
      if (scrollLeft < 2)
        disabledSide.value = "left";
      else if (trackRef.value.scrollWidth <= scrollLeft + trackRef.value.offsetWidth + 2)
        disabledSide.value = "right";
      else
        disabledSide.value = "none";
      indicatorOptions.barOffsetPercent = scrollLeft / trackRef.value.scrollWidth * 100;
      onFinishScrollingThrottled();
      onFinishScrollingDebounced(scrollLeft);
    };
    const onIndicatorScroll = ({ barOffsetPercent }, smooth = false) => {
      const scrollLeft = trackRef.value.scrollWidth * (barOffsetPercent / 100);
      setScrollLeft(scrollLeft, smooth);
    };
    const onSetIndicatorScrollStatus = (isScrolling) => {
      indicatorOptions.isScrolling = isScrolling;
    };
    let resizeObserver = null;
    onMounted(() => {
      resizeObserver = new ResizeObserver(([entry]) => {
        window.requestAnimationFrame(() => {
          width.value = entry.contentRect.width;
          nextTick(() => {
            indicatorOptions.barWidthPercent = width.value / trackRef.value.scrollWidth * 100;
          });
        });
      });
      resizeObserver.observe(trackRef.value);
      initialized.value = true;
      if (scopedCurrentItem.value !== 0)
        onMoveTo(scopedCurrentItem.value);
    });
    onBeforeUnmount(() => {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
    });
    const styles = computed(() => {
      return Object.entries({
        "--gsc-item-gap-y": itemGap.value.y,
        "--gsc-item-gap-x": itemGap.value.x,
        "--gsc-item-ssr-min-width": props.ssrItemMinWidth ? `${parseInt(props.ssrItemMinWidth.toString())}px` : "",
        "--gsc-item-ssr-max-width": props.ssrItemMaxWidth ? `${parseInt(props.ssrItemMaxWidth.toString())}px` : ""
      }).reduce((acc, [key, value]) => {
        return `${acc}${key}: ${value};`;
      }, "");
    });
    const itemStyle = computed(() => ({
      width: `calc((100% - ${props.previewSize}px) / ${props.itemsToShow})`
    }));
    expose({
      onMove,
      onMoveTo
    });
    return {
      trackRef,
      styles,
      itemStyle,
      initialized,
      disabledSide,
      indicatorOptions,
      scopedCurrentItem,
      currentItemByPercent,
      onMove,
      onMoveTo,
      onTrackScroll,
      onIndicatorScroll,
      onSetIndicatorScrollStatus
    };
  }
});
const _hoisted_1 = { class: "gsc-track__inner" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GSIndicator = resolveComponent("GSIndicator");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["gsc", {
      "gsc--scrolling": _ctx.indicatorOptions.isScrolling,
      "gsc--initialized": _ctx.initialized
    }]),
    style: normalizeStyle(_ctx.styles)
  }, [
    (openBlock(), createBlock(resolveDynamicComponent(_ctx.layout), mergeProps({
      "on-move": _ctx.onMove,
      "on-move-to": _ctx.onMoveTo,
      "disabled-side": _ctx.disabledSide,
      "current-item": _ctx.scopedCurrentItem,
      "current-item-by-percent": _ctx.currentItemByPercent,
      items: _ctx.items,
      initialized: _ctx.initialized
    }, _ctx.layoutProps), {
      track: withCtx(() => [
        createElementVNode("div", {
          ref: "trackRef",
          class: "gsc-track",
          onScrollPassive: _cache[0] || (_cache[0] = (...args) => _ctx.onTrackScroll && _ctx.onTrackScroll(...args))
        }, [
          createElementVNode("div", _hoisted_1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
              return openBlock(), createElementBlock("div", {
                key: _ctx.keyField ? item[_ctx.keyField] : index,
                class: "gsc-track__item",
                style: normalizeStyle(_ctx.itemStyle)
              }, [
                renderSlot(_ctx.$slots, "item", {
                  data: item,
                  index
                })
              ], 4);
            }), 128))
          ])
        ], 544)
      ]),
      indicator: withCtx(() => [
        createVNode(_component_GSIndicator, {
          "bar-offset-percent": _ctx.indicatorOptions.barOffsetPercent,
          "bar-width-percent": _ctx.indicatorOptions.barWidthPercent,
          onSmoothScroll: _cache[1] || (_cache[1] = ($event) => _ctx.onIndicatorScroll($event, true)),
          onScroll: _ctx.onIndicatorScroll,
          "onScroll:start": _cache[2] || (_cache[2] = ($event) => _ctx.onSetIndicatorScrollStatus(true)),
          "onScroll:end": _cache[3] || (_cache[3] = ($event) => _ctx.onSetIndicatorScrollStatus(false))
        }, null, 8, ["bar-offset-percent", "bar-width-percent", "onScroll"])
      ]),
      _: 3
    }, 16, ["on-move", "on-move-to", "disabled-side", "current-item", "current-item-by-percent", "items", "initialized"]))
  ], 6);
}
var GSCarousel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { GSCarousel };
//# sourceMappingURL=index.mjs.map
