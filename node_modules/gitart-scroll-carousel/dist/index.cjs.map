{"version":3,"file":"index.cjs","sources":["../node_modules/.pnpm/@vueuse+shared@8.2.0_vue@3.2.36/node_modules/@vueuse/shared/index.mjs","../node_modules/.pnpm/gitart-animate-number@0.1.0/node_modules/gitart-animate-number/dist/index.mjs","../src/composables/useAnimateNumber.ts","../src/components/GSIndicator.vue","../src/components/GSCarousel.vue"],"sourcesContent":["import { shallowRef, watchEffect, readonly, ref, watch, customRef, effectScope, provide, inject, getCurrentScope, onScopeDispose, isVue3, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeUnmount, onMounted, nextTick, onUnmounted } from 'vue-demi';\n\nvar __defProp$8 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$5(__spreadValues$8({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  watch(source, () => {\n    dirty.value = true;\n    trigger();\n  }, { flush: \"sync\" });\n  return customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = fn();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set() {\n      }\n    };\n  });\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    provide(key, composable(...args));\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue3();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction logicAnd(...args) {\n  return computed(() => args.every((i) => unref(i)));\n}\n\nfunction logicNot(v) {\n  return computed(() => !unref(v));\n}\n\nfunction logicOr(...args) {\n  return computed(() => args.some((i) => unref(i)));\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$7({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn) {\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unref(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj)) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !keys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  return reactive(Object.fromEntries(keys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, unref(afterMs));\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    filter(() => fn.apply(this, args), { fn, thisArg: this, args });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  const filter = (invoke) => {\n    const duration = unref(ms);\n    const maxDuration = unref(options.maxWait);\n    if (timer)\n      clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return invoke();\n    }\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(() => {\n        if (timer)\n          clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n    timer = setTimeout(() => {\n      if (maxTimer)\n        clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true) {\n  let lastExec = 0;\n  let timer;\n  let preventLeading = !leading;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n  const filter = (invoke) => {\n    const duration = unref(ms);\n    const elapsed = Date.now() - lastExec;\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration) {\n      lastExec = Date.now();\n      if (preventLeading)\n        preventLeading = false;\n      else\n        invoke();\n    }\n    if (trailing) {\n      timer = setTimeout(() => {\n        lastExec = Date.now();\n        if (!leading)\n          preventLeading = true;\n        clear();\n        invoke();\n      }, duration);\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => preventLeading = true, duration);\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || !obj[k] === void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  if (ms <= 0)\n    return value;\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = true, leading = true) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\"\n  } = options;\n  let stop1, stop2;\n  if (direction === \"both\" || direction === \"ltr\") {\n    stop1 = watch(left, (newValue) => right.value = newValue, { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    stop2 = watch(right, (newValue) => left.value = newValue, { flush, deep, immediate });\n  }\n  return () => {\n    stop1 == null ? void 0 : stop1();\n    stop2 == null ? void 0 : stop2();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          objectRef.value = __spreadProps$4(__spreadValues$6({}, objectRef.value), { [key]: v });\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction until(r) {\n  let isNot = false;\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) === !isNot) {\n          stop == null ? void 0 : stop();\n          resolve();\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).finally(() => {\n        stop == null ? void 0 : stop();\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    return toMatch((v) => v === unref(value), options);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(unref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(unref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n    };\n    return instance;\n  }\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = val;\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst formatDate = (date, formatStr) => {\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const matches = {\n    YY: String(years).slice(-2),\n    YYYY: years,\n    M: month + 1,\n    MM: `${month + 1}`.padStart(2, \"0\"),\n    D: String(days),\n    DD: `${days}`.padStart(2, \"0\"),\n    H: String(hours),\n    HH: `${hours}`.padStart(2, \"0\"),\n    h: `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: String(minutes),\n    mm: `${minutes}`.padStart(2, \"0\"),\n    s: String(seconds),\n    ss: `${seconds}`.padStart(2, \"0\"),\n    SSS: `${milliseconds}`.padStart(3, \"0\")\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]);\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\") {\n  return computed(() => formatDate(normalizeDate(unref(date)), unref(formatStr)));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (interval <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, unref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (immediate && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true\n  } = options;\n  const counter = ref(0);\n  const controls = useIntervalFn(() => counter.value += 1, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$5({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, unref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false\n  } = options;\n  const controls = useTimeoutFn(noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$4({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToggle(initialValue = false) {\n  if (isRef(initialValue)) {\n    return (value) => {\n      initialValue.value = typeof value === \"boolean\" ? value : !initialValue.value;\n      return initialValue.value;\n    };\n  } else {\n    const boolean = ref(initialValue);\n    const toggle = (value) => {\n      boolean.value = typeof value === \"boolean\" ? value : !boolean.value;\n      return boolean.value;\n    };\n    return [boolean, toggle];\n  }\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= unref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$3(__spreadValues$3({}, watchOptions), {\n    eventFilter: debounceFilter(debounce)\n  }));\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$2(__spreadValues$2({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps(__spreadValues({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue3, logicAnd as and, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isNumber, isObject, isString, isWindow, logicAnd, logicNot, logicOr, makeDestructurable, noop, normalizeDate, logicNot as not, now, objectPick, logicOr as or, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchWithFilter, whenever };\n","var NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 1e-3;\nvar SUBDIVISION_PRECISION = 1e-7;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction A(aA1, aA2) {\n  return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3 * aA2 - 6 * aA1;\n}\nfunction C(aA1) {\n  return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction LinearEasing(x) {\n  return x;\n}\nvar src = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error(\"bezier x values must be in [0, 1] range\");\n  }\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    var intervalStart = 0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\nconst easingTypes = {\n  ease: [0.25, 0.1, 0.25, 1],\n  linear: [0, 0, 1, 1],\n  easeIn: [0.42, 0, 1, 1],\n  easeOut: [0, 0, 0.58, 1],\n  easeInOut: [0.42, 0, 0.58, 1],\n  default: [0.5, 0, 0.5, 1]\n};\nconst defaults = {\n  FPS: 60,\n  BEZIER: easingTypes.default\n};\nconst animateUsingInterval = ({\n  from,\n  to,\n  duration,\n  fps = defaults.FPS,\n  bezier: bezier2 = defaults.BEZIER,\n  on,\n  completed,\n  stopped,\n  done\n}) => {\n  const easingFn = src(...bezier2);\n  const difference = to - from;\n  const frames = Math.round(duration / (1e3 / fps));\n  let frame = 1;\n  let currentValue = from;\n  const intervalId = setInterval(() => {\n    let progress = frame / frames;\n    if (progress > 1)\n      progress = 1;\n    currentValue = from + difference * easingFn(progress);\n    on(currentValue);\n    if (progress === 1) {\n      clearInterval(intervalId);\n      completed == null ? void 0 : completed(currentValue);\n      done == null ? void 0 : done(currentValue);\n    }\n    frame++;\n  }, duration / frames);\n  return () => {\n    clearInterval(intervalId);\n    stopped == null ? void 0 : stopped(currentValue);\n    done == null ? void 0 : done(currentValue);\n  };\n};\nconst animate = ({\n  from,\n  to,\n  duration,\n  bezier: bezier2 = defaults.BEZIER,\n  on,\n  completed,\n  stopped,\n  done\n}) => {\n  const easingFn = src(...bezier2);\n  const difference = to - from;\n  const timestamp = Date.now();\n  let rqfId = 0;\n  let currentValue = from;\n  const fn = () => {\n    let progress = (Date.now() - timestamp) / duration;\n    if (progress > 1)\n      progress = 1;\n    currentValue = from + difference * easingFn(progress);\n    on(currentValue);\n    if (progress === 1) {\n      completed == null ? void 0 : completed(currentValue);\n      done == null ? void 0 : done(currentValue);\n      return;\n    }\n    rqfId = requestAnimationFrame(fn);\n  };\n  rqfId = requestAnimationFrame(fn);\n  return () => {\n    cancelAnimationFrame(rqfId);\n    stopped == null ? void 0 : stopped(currentValue);\n    done == null ? void 0 : done(currentValue);\n  };\n};\nexport { animate, animateUsingInterval, easingTypes };\n//# sourceMappingURL=index.mjs.map\n","import { animate } from 'gitart-animate-number'\n\nexport const useAnimateNumber = (onChangeValue: (value: number) => void) => {\n  let value = 0\n  let stopFn: (null | (() => void)) = null\n\n  const setSmoothly = (to: number, from?: number) => {\n    stopFn?.()\n\n    if (from)\n      value = from\n\n    stopFn = animate({\n      duration: 400,\n      from: value,\n      to,\n      on: (current) => {\n        value = current\n        onChangeValue(current)\n      },\n    })\n  }\n\n  const setImmediately = (to: number) => {\n    value = to\n    onChangeValue(to)\n  }\n\n  return {\n    setSmoothly,\n    setImmediately,\n  }\n}\n","<script lang=\"ts\">\nimport { computed, defineComponent, ref } from 'vue'\n\nexport default defineComponent({\n  name: 'GSIndicator',\n  props: {\n    barWidthPercent: {\n      type: Number,\n      required: true,\n    },\n\n    barOffsetPercent: {\n      type: Number,\n      required: true,\n    },\n  },\n\n  emits: {\n    'smooth-scroll': (_: { barOffsetPercent: number }) => true,\n    'scroll': (_: { barOffsetPercent: number }) => true,\n    'scroll:start': () => true,\n    'scroll:end': () => true,\n  },\n\n  setup(props, { emit }) {\n    const indicatorRef = ref<HTMLDivElement | null>()\n    const startBarX = ref(0)\n    const startBarOffsetPercent = ref(0)\n    const isScrolling = ref(false)\n\n    const mouseMoveHandler = (event: MouseEvent) => {\n      const barX = event.clientX\n\n      const difference = barX - startBarX.value\n\n      const width = indicatorRef.value!.offsetWidth\n\n      const differencePercent = (difference / width) * 100\n\n      const minOffset = 0\n      const maxOffset = 100 - props.barWidthPercent\n\n      let barOffsetPercent = startBarOffsetPercent.value + differencePercent\n      if (barOffsetPercent < minOffset)\n        barOffsetPercent = minOffset\n\n      else if (barOffsetPercent > maxOffset)\n        barOffsetPercent = maxOffset\n\n      emit('scroll', {\n        barOffsetPercent,\n      })\n    }\n\n    const mouseUpHandler = () => {\n      document.removeEventListener('mouseup', mouseUpHandler)\n      document.removeEventListener('mousemove', mouseMoveHandler)\n      isScrolling.value = false\n      emit('scroll:end')\n    }\n\n    const onMouseDown = (event: MouseEvent) => {\n      isScrolling.value = true\n      emit('scroll:start')\n\n      document.addEventListener('mouseup', mouseUpHandler)\n      document.addEventListener('mousemove', mouseMoveHandler)\n\n      startBarX.value = event.clientX\n      startBarOffsetPercent.value = props.barOffsetPercent\n    }\n\n    const onTrackClick = (event: MouseEvent) => {\n      const x = event.clientX\n\n      const indicatorEl = indicatorRef.value!\n      const indicatorX = indicatorEl.getBoundingClientRect().left\n      const relativeX = x - indicatorX\n\n      const relativePosition = relativeX / indicatorEl.offsetWidth\n\n      const barOffsetPercent = (relativePosition - (props.barWidthPercent / 100 / 2)) * 100\n      emit('smooth-scroll', {\n        barOffsetPercent,\n      })\n    }\n\n    const barStyle = computed(() => {\n      return {\n        width: `${props.barWidthPercent}%`,\n        left: `${props.barOffsetPercent}%`,\n      }\n    })\n\n    return {\n      indicatorRef,\n\n      barStyle,\n      startBarX,\n      startBarOffsetPercent,\n      moving: isScrolling,\n      onTrackClick,\n      onMouseDown,\n    }\n  },\n})\n</script>\n\n<template>\n  <div\n    ref=\"indicatorRef\"\n    class=\"gsc-indicator\"\n    :class=\"{\n      'gsc-indicator--scrolling': moving,\n    }\"\n  >\n    <div class=\"gsc-indicator__track\" @click=\"onTrackClick\" />\n    <div\n      class=\"gsc-indicator__bar\"\n      :style=\"barStyle\"\n      @mousedown=\"onMouseDown\"\n    />\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.gsc-indicator {\n  --indicator-height: 26px;\n\n  height: var(--indicator-height);\n  display: flex;\n  align-items: center;\n  position: relative;\n\n  &__track {\n    height: 4px;\n    background: var(--gsc-indicator-track-color);\n    border-radius: 5px;\n    width: 100%;\n    transition: height 0.15s;\n    position: relative;\n\n    &::after {\n      content: \" \";\n      position: absolute;\n      top: calc(-1 * (var(--indicator-height) / 2));\n      bottom: calc(-1 * (var(--indicator-height) / 2));\n      left: 0;\n      right: 0;\n      display: block;\n    }\n  }\n\n  &__bar {\n    position: absolute;\n    z-index: 2;\n    left: 0;\n    top: 50%;\n    transform: translate(0, -50%);\n    background: var(--gsc-indicator-bar-color);\n    cursor: grab;\n    height: 4px;\n    width: 0; // 0 by default\n    border-radius: 4px;\n    transition: height 0.15s;\n\n    &::after {\n      content: \" \";\n      position: absolute;\n      top: calc(-1 * (var(--indicator-height) / 2));\n      bottom: calc(-1 * (var(--indicator-height) / 2));\n      left: 0;\n      right: 0;\n      display: block;\n    }\n  }\n\n  &:hover,\n  &--scrolling {\n    .gsc-indicator__track {\n      height: 6px;\n    }\n\n    .gsc-indicator__bar {\n      height: 8px;\n    }\n  }\n\n  &--scrolling {\n    .gsc-indicator__bar {\n      height: 10px !important;\n    }\n  }\n}\n</style>\n","<script lang=\"ts\">\nimport type { ComponentPublicInstance, PropType, ShallowUnwrapRef } from 'vue'\nimport { computed, defineComponent, nextTick, onBeforeUnmount, onMounted, reactive, ref, watch } from 'vue'\nimport { useDebounceFn, useThrottleFn } from '@vueuse/core'\n\nimport { useAnimateNumber } from '../composables/useAnimateNumber'\n\nimport GSIndicator from './GSIndicator.vue'\n\nexport default defineComponent({\n  name: 'GSCarousel',\n  components: {\n    GSIndicator,\n  },\n  props: {\n    currentItem: {\n      type: Number,\n      default: 0,\n    },\n\n    items: {\n      type: Array as PropType<any[]>,\n      required: true,\n    },\n\n    // How much items in the view\n    itemsToShow: {\n      type: Number,\n      required: true,\n    },\n\n    // Key field name for :key in v-for\n    // (using index by default)\n    keyField: {\n      type: String,\n      default: null,\n    },\n\n    // Gap around each item.\n    // Value '12' means 'padding: 6px;' for each item.\n    // Value '12 20' means 'padding: 6px 10px;' for each item.\n    itemGap: {\n      type: [String, Number],\n      default: '0',\n      validator: (value: string | number) => {\n        const gaps = value.toString().split(' ')\n        return gaps.length <= 2 && gaps.every((gap: string) => !isNaN(parseInt(gap)))\n      },\n    },\n\n    // The visible part of the next element in the carousel\n    previewSize: {\n      type: Number,\n      default: 120,\n    },\n\n    // Enables sticking to the sides of the carousel\n    sticky: {\n      type: Boolean,\n      default: false,\n    },\n\n    // layout component\n    layout: {\n      type: Object as PropType<ComponentPublicInstance | ShallowUnwrapRef<ComponentPublicInstance>>,\n      required: true,\n    },\n\n    // layout specific props\n    layoutProps: {\n      type: Object as PropType<Object>,\n      required: false,\n      default: null,\n    },\n\n    /**\n     * Item min-width on app startup when html is displayed,\n     * but js is not loaded yet.\n     * It correct's the item width in SSR mode.\n     */\n    ssrItemMinWidth: {\n      type: [Number, String],\n      default: null,\n    },\n\n    /**\n     * Item max-width on app startup when html is displayed,\n     * but js is not loaded yet.\n     * It correct's the item width in SSR mode.\n     */\n    ssrItemMaxWidth: {\n      type: [Number, String],\n      default: null,\n    },\n  },\n\n  emits: {\n    'update:current-item': (value: number) => true,\n  },\n\n  setup(props, { emit, expose }) {\n    const initialized = ref(false)\n    const trackRef = ref<HTMLElement | null>()\n    const disabledSide = ref<'left' | 'right' | 'none'>('left')\n    const width = ref(0)\n\n    const scopedCurrentItem = ref(props.currentItem || 0)\n    watch(() => props.currentItem, (val) => {\n      scopedCurrentItem.value = val\n    })\n\n    const indicatorOptions = reactive({\n      isScrolling: false,\n      barOffsetPercent: 0,\n      barWidthPercent: 0,\n    })\n\n    const currentItemByPercent = computed(() => {\n      const scrollPercent = (indicatorOptions.barOffsetPercent / (100 - indicatorOptions.barWidthPercent))\n      const item = Math.floor(scrollPercent * (props.items.length - 1))\n      return item\n    })\n\n    const {\n      setImmediately,\n      setSmoothly,\n    } = useAnimateNumber((offset: number) =>\n      trackRef.value?.scrollTo({\n        left: offset,\n      }),\n    )\n\n    const itemGap = computed(() => {\n      const gapsArr = props.itemGap.toString().split(' ').map(g => parseInt(g))\n      const y = gapsArr[0]\n      const x = gapsArr.length === 1 ? y : gapsArr[1]\n\n      return { y, x }\n    })\n\n    const itemWidth = computed(() => {\n      return width.value ? (width.value - props.previewSize) / props.itemsToShow : 0\n    })\n\n    const setScrollLeft = (newScrollLeft: number, smooth = true) => {\n      if (smooth) {\n        const currentScrollLeft = trackRef.value!.scrollLeft\n        setSmoothly(newScrollLeft, currentScrollLeft)\n      }\n      else {\n        setImmediately(newScrollLeft)\n      }\n    }\n\n    const getCurrentItem = () => {\n      const scrollLeft = trackRef.value!.scrollLeft\n\n      const rawDecimal = scrollLeft / itemWidth.value\n      const absence = 1 - (rawDecimal - Math.floor(rawDecimal))\n\n      let item\n      if (absence < 0.09)\n        item = Math.floor(rawDecimal) + 1\n      else\n        item = Math.floor(rawDecimal)\n\n      // The item shouldn't be scrolled out\n      if (item * itemWidth.value < scrollLeft)\n        item += 1\n\n      if (item > props.items.length - 1)\n        item = props.items.length - 1\n\n      return item\n    }\n\n    /**\n     * Event handlers\n     */\n\n    const onMove = (move: number) => {\n      const scrollLeft = trackRef.value!.scrollLeft\n      const item = getCurrentItem()\n\n      if (move === 1) {\n        let itemToScroll = item + props.itemsToShow\n\n        // to not scrolled out a partially visible item\n        // we decrement the itemToScroll by 1\n        // (should be before max item check)\n        const isLastInvisible = ((item * itemWidth.value) - props.previewSize - 2) > (scrollLeft)\n        if (isLastInvisible)\n          itemToScroll -= 1\n\n        // Last item to scroll\n        const maxItem = props.items.length - props.itemsToShow\n        if (itemToScroll > maxItem)\n          itemToScroll = maxItem\n\n        const newScrollLeft = itemWidth.value * itemToScroll\n        setScrollLeft(newScrollLeft)\n      }\n      else if (move === -1) {\n        if (item === 0)\n          return\n\n        let itemToScroll = item - props.itemsToShow\n        if (itemToScroll < 0)\n          itemToScroll = 0\n\n        const newScrollLeft = (itemWidth.value * itemToScroll) - props.previewSize\n        setScrollLeft(newScrollLeft)\n      }\n    }\n\n    const onMoveTo = (index: number) => {\n      if (!itemWidth.value) {\n        setTimeout(() => {\n          onMoveTo(index)\n        }, 50)\n        return\n      }\n\n      if (index > getCurrentItem()) {\n        const newScrollLeft = itemWidth.value * index\n        setScrollLeft(newScrollLeft)\n        return\n      }\n\n      const newScrollLeft = (itemWidth.value * index) - props.previewSize\n      setScrollLeft(newScrollLeft)\n    }\n\n    const onFinishScrollingThrottled = useThrottleFn(() => {\n      const item = getCurrentItem()\n      if (item !== scopedCurrentItem.value) {\n        scopedCurrentItem.value = item\n        emit('update:current-item', scopedCurrentItem.value)\n      }\n    }, 200)\n\n    let prevScrollLeft = 0\n    const onFinishScrollingDebounced = useDebounceFn((scrollLeft: number) => {\n      setImmediately(scrollLeft)\n\n      if (!props.sticky || indicatorOptions.isScrolling)\n        return\n\n      // move to right on any move\n      if (prevScrollLeft < scrollLeft) {\n        const newScrollLeft = (itemWidth.value * scopedCurrentItem.value)\n        setScrollLeft(newScrollLeft)\n      }\n      // move to left if the carousel is scrolled more than previewSize\n      else if (Math.abs((itemWidth.value * scopedCurrentItem.value) - scrollLeft) > (props.previewSize + 2)) {\n        const newScrollLeft = (itemWidth.value * (scopedCurrentItem.value - 1)) - props.previewSize\n        setScrollLeft(newScrollLeft)\n      }\n\n      prevScrollLeft = scrollLeft\n    }, 300)\n\n    const onTrackScroll = () => {\n      const scrollLeft = trackRef.value!.scrollLeft\n\n      if (scrollLeft < 2)\n        disabledSide.value = 'left'\n\n      else if (trackRef.value!.scrollWidth <= (scrollLeft + trackRef.value!.offsetWidth + 2))\n        disabledSide.value = 'right'\n\n      else\n        disabledSide.value = 'none'\n\n      indicatorOptions.barOffsetPercent = (scrollLeft / trackRef.value!.scrollWidth) * 100\n\n      onFinishScrollingThrottled()\n      onFinishScrollingDebounced(scrollLeft)\n    }\n\n    const onIndicatorScroll = ({ barOffsetPercent }: { barOffsetPercent: number }, smooth = false) => {\n      const scrollLeft = trackRef.value!.scrollWidth * (barOffsetPercent / 100)\n      setScrollLeft(scrollLeft, smooth)\n    }\n\n    const onSetIndicatorScrollStatus = (isScrolling: boolean) => {\n      indicatorOptions.isScrolling = isScrolling\n    }\n\n    /**\n     * Life Circles\n     */\n\n    let resizeObserver: ResizeObserver | null = null\n    onMounted(() => {\n      resizeObserver = new ResizeObserver(([entry]) => {\n        window.requestAnimationFrame(() => {\n          width.value = entry.contentRect.width\n          nextTick(() => {\n            indicatorOptions.barWidthPercent = (width.value / trackRef.value!.scrollWidth) * 100\n          })\n        })\n      })\n\n      resizeObserver.observe(trackRef.value as HTMLElement)\n\n      initialized.value = true\n\n      if (scopedCurrentItem.value !== 0)\n        onMoveTo(scopedCurrentItem.value)\n    })\n    onBeforeUnmount(() => {\n      resizeObserver?.disconnect()\n    })\n\n    /**\n     * Styles/Classes\n     */\n\n    const styles = computed(() => {\n      return Object.entries({\n        '--gsc-item-gap-y': itemGap.value.y,\n        '--gsc-item-gap-x': itemGap.value.x,\n        '--gsc-item-ssr-min-width': props.ssrItemMinWidth ? `${parseInt(props.ssrItemMinWidth.toString())}px` : '',\n        '--gsc-item-ssr-max-width': props.ssrItemMaxWidth ? `${parseInt(props.ssrItemMaxWidth.toString())}px` : '',\n      }).reduce((acc, [key, value]) => {\n        return `${acc}${key}: ${value};`\n      }, '')\n    })\n\n    const itemStyle = computed(() => ({\n      width: `calc((100% - ${props.previewSize}px) / ${props.itemsToShow})`,\n    }))\n\n    expose({\n      onMove,\n      onMoveTo,\n    })\n\n    return {\n      trackRef,\n\n      styles,\n      itemStyle,\n      initialized,\n      disabledSide,\n      indicatorOptions,\n      scopedCurrentItem,\n      currentItemByPercent,\n      onMove,\n      onMoveTo,\n      onTrackScroll,\n      onIndicatorScroll,\n      onSetIndicatorScrollStatus,\n    }\n  },\n})\n</script>\n\n<template>\n  <div\n    class=\"gsc\"\n    :class=\"{\n      'gsc--scrolling': indicatorOptions.isScrolling,\n      'gsc--initialized': initialized,\n    }\"\n    :style=\"styles\"\n  >\n    <Component\n      :is=\"layout\"\n      :on-move=\"onMove\"\n      :on-move-to=\"onMoveTo\"\n      :disabled-side=\"disabledSide\"\n      :current-item=\"scopedCurrentItem\"\n      :current-item-by-percent=\"currentItemByPercent\"\n      :items=\"items\"\n      :initialized=\"initialized\"\n      v-bind=\"layoutProps\"\n    >\n      <template #track>\n        <div\n          ref=\"trackRef\"\n          class=\"gsc-track\"\n          @scroll.passive=\"onTrackScroll\"\n        >\n          <div class=\"gsc-track__inner\">\n            <div\n              v-for=\"(item, index) in items\"\n              :key=\"keyField ? item[keyField] : index\"\n              class=\"gsc-track__item\"\n              :style=\"itemStyle\"\n            >\n              <slot\n                name=\"item\"\n                :data=\"item\"\n                :index=\"index\"\n              />\n            </div>\n          </div>\n        </div>\n      </template>\n      <template #indicator>\n        <GSIndicator\n          :bar-offset-percent=\"indicatorOptions.barOffsetPercent\"\n          :bar-width-percent=\"indicatorOptions.barWidthPercent\"\n          @smooth-scroll=\"onIndicatorScroll($event, true)\"\n          @scroll=\"onIndicatorScroll\"\n          @scroll:start=\"onSetIndicatorScrollStatus(true)\"\n          @scroll:end=\"onSetIndicatorScrollStatus(false)\"\n        />\n      </template>\n    </Component>\n  </div>\n</template>\n\n<style lang=\"scss\">\n.gsc {\n  --gsc-arrow-bg: var(--gsc-custom-arrow-bg, #000);\n  --gsc-arrow-bg-hover: var(--gsc-custom-arrow-bg-hover, #222);\n  --gsc-arrow-bg-disabled: var(--gsc-custom-arrow-bg-disabled, #d3d3d3);\n  --gsc-arrow-color: var(--gsc-custom-arrow-color, #fff);\n  --gsc-indicator-bar-color: var(--gsc-custom-indicator-bar-color, #212121);\n  --gsc-indicator-track-color: var(--gsc-custom-indicator-track-color, #e0e0e0);\n\n  &--scrolling {\n    user-select: none;\n  }\n\n  &:not(.gsc--initialized) {\n    .gsc-track__item {\n      min-width: var(--gsc-item-ssr-min-width) !important;\n      max-width: var(--gsc-item-ssr-max-width) !important;\n    }\n  }\n}\n\n.gsc-track {\n  overflow-x: auto;\n  overflow-y: hidden;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  &__inner {\n    display: flex;\n  }\n\n  &__item {\n    padding: calc(var(--gsc-item-gap-y) * 1px) calc(var(--gsc-item-gap-x) * 1px);\n    flex-shrink: 0;\n  }\n}\n</style>\n"],"names":["unref","_sfc_main","defineComponent","ref","computed","_createElementBlock","_normalizeClass","_createElementVNode","_normalizeStyle","watch","reactive","onMounted","nextTick","onBeforeUnmount","_createBlock","_resolveDynamicComponent","_mergeProps","_withCtx","_openBlock","_Fragment","_renderList","_renderSlot","_createVNode"],"mappings":"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"}