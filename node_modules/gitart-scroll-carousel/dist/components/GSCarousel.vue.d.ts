import type { ComponentPublicInstance, PropType, ShallowUnwrapRef } from 'vue';
declare const _default: import("vue").DefineComponent<{
    currentItem: {
        type: NumberConstructor;
        default: number;
    };
    items: {
        type: PropType<any[]>;
        required: true;
    };
    itemsToShow: {
        type: NumberConstructor;
        required: true;
    };
    keyField: {
        type: StringConstructor;
        default: null;
    };
    itemGap: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
        validator: (value: string | number) => boolean;
    };
    previewSize: {
        type: NumberConstructor;
        default: number;
    };
    sticky: {
        type: BooleanConstructor;
        default: boolean;
    };
    layout: {
        type: PropType<ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | ShallowUnwrapRef<ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>>>;
        required: true;
    };
    layoutProps: {
        type: PropType<Object>;
        required: false;
        default: null;
    };
    /**
     * Item min-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMinWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: null;
    };
    /**
     * Item max-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMaxWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: null;
    };
}, {
    trackRef: import("vue").Ref<HTMLElement | null | undefined>;
    styles: import("vue").ComputedRef<string>;
    itemStyle: import("vue").ComputedRef<{
        width: string;
    }>;
    initialized: import("vue").Ref<boolean>;
    disabledSide: import("vue").Ref<"left" | "right" | "none">;
    indicatorOptions: {
        isScrolling: boolean;
        barOffsetPercent: number;
        barWidthPercent: number;
    };
    scopedCurrentItem: import("vue").Ref<number>;
    currentItemByPercent: import("vue").ComputedRef<number>;
    onMove: (move: number) => void;
    onMoveTo: (index: number) => void;
    onTrackScroll: () => void;
    onIndicatorScroll: ({ barOffsetPercent }: {
        barOffsetPercent: number;
    }, smooth?: boolean) => void;
    onSetIndicatorScrollStatus: (isScrolling: boolean) => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    'update:current-item': (value: number) => true;
}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    currentItem: {
        type: NumberConstructor;
        default: number;
    };
    items: {
        type: PropType<any[]>;
        required: true;
    };
    itemsToShow: {
        type: NumberConstructor;
        required: true;
    };
    keyField: {
        type: StringConstructor;
        default: null;
    };
    itemGap: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
        validator: (value: string | number) => boolean;
    };
    previewSize: {
        type: NumberConstructor;
        default: number;
    };
    sticky: {
        type: BooleanConstructor;
        default: boolean;
    };
    layout: {
        type: PropType<ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | ShallowUnwrapRef<ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>>>;
        required: true;
    };
    layoutProps: {
        type: PropType<Object>;
        required: false;
        default: null;
    };
    /**
     * Item min-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMinWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: null;
    };
    /**
     * Item max-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMaxWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: null;
    };
}>> & {
    "onUpdate:current-item"?: ((value: number) => any) | undefined;
}, {
    currentItem: number;
    keyField: string;
    itemGap: string | number;
    previewSize: number;
    sticky: boolean;
    layoutProps: Object;
    ssrItemMinWidth: string | number;
    ssrItemMaxWidth: string | number;
}>;
export default _default;
//# sourceMappingURL=GSCarousel.vue.d.ts.map